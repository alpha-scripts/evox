{"version":3,"sources":["turbopack:///[project]/Tictactoe/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts","turbopack:///[project]/Tictactoe/node_modules/next/src/server/route-modules/app-page/vendored/contexts/app-router-context.ts","turbopack:///[project]/Tictactoe/node_modules/next/src/server/route-modules/app-page/vendored/contexts/hooks-client-context.ts","turbopack:///[project]/Tictactoe/node_modules/next/src/server/route-modules/app-page/vendored/contexts/server-inserted-html.ts","turbopack:///[project]/Tictactoe/node_modules/next/src/server/route-modules/app-page/module.compiled.js","turbopack:///[project]/Tictactoe/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.ts","turbopack:///[project]/Tictactoe/src/lib/game.ts","turbopack:///[project]/Tictactoe/app/page.tsx"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['contexts'].AppRouterContext\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['contexts'].HooksClientContext\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['contexts'].ServerInsertedHtml\n","if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxRuntime\n","export type Player = \"X\" | \"O\" | null;\r\nexport type Board = Player[];\r\n\r\n/**\r\n * Creates an empty 3x3 Tic Tac Toe board\r\n * @returns Array of 9 null values representing an empty board\r\n */\r\nexport function createEmptyBoard(): Board {\r\n  return Array(9).fill(null);\r\n}\r\n\r\n/**\r\n * Makes a move on the board at the specified index\r\n * @param board - Current board state\r\n * @param index - Index where the move should be made (0-8)\r\n * @param player - Player making the move (\"X\" or \"O\")\r\n * @returns New board state with the move made, or null if move is invalid\r\n */\r\nexport function makeMove(\r\n  board: Board,\r\n  index: number,\r\n  player: \"X\" | \"O\"\r\n): Board | null {\r\n  // Validate inputs\r\n  if (index < 0 || index > 8) {\r\n    return null; // Invalid index\r\n  }\r\n\r\n  if (board[index] !== null) {\r\n    return null; // Cell already occupied\r\n  }\r\n\r\n  if (player !== \"X\" && player !== \"O\") {\r\n    return null; // Invalid player\r\n  }\r\n\r\n  // Create a new board with the move\r\n  const newBoard = [...board];\r\n  newBoard[index] = player;\r\n  return newBoard;\r\n}\r\n\r\n/**\r\n * Checks if there's a winner on the board\r\n * @param board - Current board state\r\n * @returns The winner (\"X\" or \"O\"), \"draw\" if board is full with no winner, or null if game continues\r\n */\r\nexport function checkWinner(board: Board): Player | \"draw\" | null {\r\n  // Winning combinations (indices)\r\n  const winningCombinations = [\r\n    [0, 1, 2], // Top row\r\n    [3, 4, 5], // Middle row\r\n    [6, 7, 8], // Bottom row\r\n    [0, 3, 6], // Left column\r\n    [1, 4, 7], // Middle column\r\n    [2, 5, 8], // Right column\r\n    [0, 4, 8], // Diagonal top-left to bottom-right\r\n    [2, 4, 6], // Diagonal top-right to bottom-left\r\n  ];\r\n\r\n  // Check each winning combination\r\n  for (const combination of winningCombinations) {\r\n    const [a, b, c] = combination;\r\n    if (board[a] && board[a] === board[b] && board[a] === board[c]) {\r\n      return board[a]; // Return the winner\r\n    }\r\n  }\r\n\r\n  // Check for draw (board is full and no winner)\r\n  if (isBoardFull(board)) {\r\n    return \"draw\";\r\n  }\r\n\r\n  // No winner yet, game continues\r\n  return null;\r\n}\r\n\r\n/**\r\n * Gets the winning cell indices if there's a winner\r\n * @param board - Current board state\r\n * @returns Array of winning cell indices, or empty array if no winner\r\n */\r\nexport function getWinningCells(board: Board): number[] {\r\n  const winningCombinations = [\r\n    [0, 1, 2], // Top row\r\n    [3, 4, 5], // Middle row\r\n    [6, 7, 8], // Bottom row\r\n    [0, 3, 6], // Left column\r\n    [1, 4, 7], // Middle column\r\n    [2, 5, 8], // Right column\r\n    [0, 4, 8], // Diagonal top-left to bottom-right\r\n    [2, 4, 6], // Diagonal top-right to bottom-left\r\n  ];\r\n\r\n  // Check each winning combination\r\n  for (const combination of winningCombinations) {\r\n    const [a, b, c] = combination;\r\n    if (board[a] && board[a] === board[b] && board[a] === board[c]) {\r\n      return combination; // Return the winning combination\r\n    }\r\n  }\r\n\r\n  // No winner\r\n  return [];\r\n}\r\n\r\n/**\r\n * Checks if the board is full (no empty cells)\r\n * @param board - Current board state\r\n * @returns True if board is full, false otherwise\r\n */\r\nexport function isBoardFull(board: Board): boolean {\r\n  return board.every((cell) => cell !== null);\r\n}\r\n\r\n/**\r\n * Gets all available move indices (empty cells)\r\n * @param board - Current board state\r\n * @returns Array of indices where moves can be made\r\n */\r\nexport function getAvailableMoves(board: Board): number[] {\r\n  return board\r\n    .map((cell, index) => (cell === null ? index : -1))\r\n    .filter((index) => index !== -1);\r\n}\r\n\r\n/**\r\n * Difficulty levels for AI opponent\r\n */\r\nexport type Difficulty = \"easy\" | \"medium\" | \"hard\";\r\n\r\n/**\r\n * Gets the opponent player\r\n * @param player - Current player\r\n * @returns The opponent player\r\n */\r\nfunction getOpponent(player: \"X\" | \"O\"): \"X\" | \"O\" {\r\n  return player === \"X\" ? \"O\" : \"X\";\r\n}\r\n\r\n/**\r\n * Evaluates the board state from a player's perspective\r\n * @param board - Current board state\r\n * @param player - Player to evaluate for\r\n * @returns Score: 10 for win, -10 for loss, 0 for draw/ongoing\r\n */\r\nfunction evaluateBoard(board: Board, player: \"X\" | \"O\"): number {\r\n  const winner = checkWinner(board);\r\n  \r\n  if (winner === player) {\r\n    return 10; // Player wins\r\n  } else if (winner === getOpponent(player)) {\r\n    return -10; // Opponent wins\r\n  } else if (winner === \"draw\") {\r\n    return 0; // Draw\r\n  }\r\n  \r\n  return 0; // Game ongoing\r\n}\r\n\r\n/**\r\n * Heuristic to evaluate move quality based on position\r\n * Center > Corners > Edges\r\n * @param move - Move index\r\n * @returns Heuristic score (higher is better)\r\n */\r\nfunction getMoveHeuristic(move: number): number {\r\n  const center = 4;\r\n  const corners = [0, 2, 6, 8];\r\n  const edges = [1, 3, 5, 7];\r\n  \r\n  if (move === center) return 3;\r\n  if (corners.includes(move)) return 2;\r\n  if (edges.includes(move)) return 1;\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Minimax algorithm to find the best move\r\n * @param board - Current board state\r\n * @param player - Current player\r\n * @param depth - Maximum depth to search\r\n * @param isMaximizing - Whether we're maximizing or minimizing\r\n * @param currentDepth - Current depth in the search tree\r\n * @returns Score and best move index\r\n */\r\nfunction minimax(\r\n  board: Board,\r\n  player: \"X\" | \"O\",\r\n  depth: number,\r\n  isMaximizing: boolean,\r\n  currentDepth: number = 0\r\n): { score: number; move: number | null } {\r\n  const winner = checkWinner(board);\r\n  \r\n  // Terminal states\r\n  if (winner === player) {\r\n    return { score: 10 - currentDepth, move: null }; // Prefer faster wins\r\n  } else if (winner === getOpponent(player)) {\r\n    return { score: currentDepth - 10, move: null }; // Prefer slower losses\r\n  } else if (winner === \"draw\" || isBoardFull(board)) {\r\n    return { score: 0, move: null };\r\n  }\r\n  \r\n  // Depth limit reached\r\n  if (currentDepth >= depth) {\r\n    return { score: 0, move: null };\r\n  }\r\n  \r\n  const availableMoves = getAvailableMoves(board);\r\n  \r\n  // Sort moves by heuristic (center > corners > edges) for better move selection\r\n  const sortedMoves = [...availableMoves].sort((a, b) => {\r\n    return getMoveHeuristic(b) - getMoveHeuristic(a);\r\n  });\r\n  \r\n  if (isMaximizing) {\r\n    let bestScore = -Infinity;\r\n    let bestMove = sortedMoves[0] || null;\r\n    let bestHeuristic = -1;\r\n    \r\n    for (const move of sortedMoves) {\r\n      const newBoard = makeMove(board, move, player);\r\n      if (!newBoard) continue;\r\n      \r\n      const result = minimax(\r\n        newBoard,\r\n        player,\r\n        depth,\r\n        false,\r\n        currentDepth + 1\r\n      );\r\n      \r\n      const moveHeuristic = getMoveHeuristic(move);\r\n      \r\n      // Prefer moves with better score, or equal score with better heuristic\r\n      if (\r\n        result.score > bestScore ||\r\n        (result.score === bestScore && moveHeuristic > bestHeuristic)\r\n      ) {\r\n        bestScore = result.score;\r\n        bestMove = move;\r\n        bestHeuristic = moveHeuristic;\r\n      }\r\n    }\r\n    \r\n    return { score: bestScore, move: bestMove };\r\n  } else {\r\n    // Minimizing: opponent's turn\r\n    let bestScore = Infinity;\r\n    \r\n    for (const move of sortedMoves) {\r\n      const newBoard = makeMove(board, move, getOpponent(player));\r\n      if (!newBoard) continue;\r\n      \r\n      const result = minimax(\r\n        newBoard,\r\n        player,\r\n        depth,\r\n        true,\r\n        currentDepth + 1\r\n      );\r\n      \r\n      if (result.score < bestScore) {\r\n        bestScore = result.score;\r\n      }\r\n    }\r\n    \r\n    return { score: bestScore, move: null }; // No move in minimizing branch\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the best move for an AI player based on difficulty\r\n * @param board - Current board state\r\n * @param player - AI player (\"X\" or \"O\")\r\n * @param difficulty - AI difficulty level (\"easy\" | \"medium\" | \"hard\")\r\n * @returns The index of the best move, or null if no moves available\r\n */\r\nexport function getBestMove(\r\n  board: Board,\r\n  player: \"X\" | \"O\",\r\n  difficulty: Difficulty = \"medium\"\r\n): number | null {\r\n  const availableMoves = getAvailableMoves(board);\r\n  \r\n  if (availableMoves.length === 0) {\r\n    return null; // No moves available\r\n  }\r\n  \r\n  // Easy: random move\r\n  if (difficulty === \"easy\") {\r\n    const randomIndex = Math.floor(Math.random() * availableMoves.length);\r\n    return availableMoves[randomIndex];\r\n  }\r\n  \r\n  // Medium: shallow minimax (depth 2)\r\n  if (difficulty === \"medium\") {\r\n    const result = minimax(board, player, 2, true);\r\n    return result.move;\r\n  }\r\n  \r\n  // Hard: full minimax (depth 9 for complete game tree)\r\n  if (difficulty === \"hard\") {\r\n    const result = minimax(board, player, 9, true);\r\n    return result.move;\r\n  }\r\n  \r\n  // Fallback to medium\r\n  const result = minimax(board, player, 2, true);\r\n  return result.move;\r\n}\r\n\r\n","\"use client\";\r\n\r\nimport { useState, useEffect, useCallback, useRef } from \"react\";\r\nimport { motion, AnimatePresence } from \"framer-motion\";\r\nimport { Board, Header, Controls } from \"@/src/components\";\r\nimport {\r\n  createEmptyBoard,\r\n  makeMove,\r\n  checkWinner,\r\n  getBestMove,\r\n  getWinningCells,\r\n  type Board as BoardType,\r\n  type Player,\r\n  type Difficulty,\r\n} from \"@/src/lib/game\";\r\n\r\nexport default function Home() {\r\n  const [board, setBoard] = useState<BoardType>(createEmptyBoard());\r\n  const [currentPlayer, setCurrentPlayer] = useState<Player>(\"X\");\r\n  const [winner, setWinner] = useState<Player | \"draw\" | null>(null);\r\n  const [gameMode, setGameMode] = useState<\"1P\" | \"2P\">(\"2P\");\r\n  const [difficulty, setDifficulty] = useState<Difficulty>(\"medium\");\r\n  const [winningCells, setWinningCells] = useState<number[]>([]);\r\n  const [isAITurning, setIsAITurning] = useState(false);\r\n  const aiMoveTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n  const isAIMovingRef = useRef(false);\r\n  const boardRef = useRef<BoardType>(board);\r\n  \r\n  // Keep board ref in sync with board state\r\n  useEffect(() => {\r\n    boardRef.current = board;\r\n  }, [board]);\r\n\r\n  // Check for winner after each move\r\n  useEffect(() => {\r\n    const gameWinner = checkWinner(board);\r\n    setWinner(gameWinner);\r\n    \r\n    if (gameWinner && gameWinner !== \"draw\") {\r\n      const cells = getWinningCells(board);\r\n      setWinningCells(cells);\r\n    } else {\r\n      setWinningCells([]);\r\n    }\r\n  }, [board]);\r\n\r\n  // Handle AI move in 1P mode\r\n  useEffect(() => {\r\n    // Clean up any pending AI move\r\n    const cleanup = () => {\r\n      if (aiMoveTimeoutRef.current) {\r\n        clearTimeout(aiMoveTimeoutRef.current);\r\n        aiMoveTimeoutRef.current = null;\r\n      }\r\n      isAIMovingRef.current = false;\r\n    };\r\n\r\n    // Only trigger AI move if conditions are met\r\n    if (\r\n      gameMode === \"1P\" &&\r\n      !winner &&\r\n      currentPlayer === \"O\" &&\r\n      !isAIMovingRef.current\r\n    ) {\r\n      cleanup(); // Clean up any existing timeout\r\n      isAIMovingRef.current = true;\r\n      setIsAITurning(true);\r\n      \r\n      // Add a small delay for better UX\r\n      aiMoveTimeoutRef.current = setTimeout(() => {\r\n        // Get latest board state from ref\r\n        const currentBoardState = boardRef.current;\r\n        \r\n        // Check if game is still ongoing\r\n        const gameWinner = checkWinner(currentBoardState);\r\n        if (gameWinner) {\r\n          isAIMovingRef.current = false;\r\n          setIsAITurning(false);\r\n          aiMoveTimeoutRef.current = null;\r\n          return;\r\n        }\r\n        \r\n        // Make AI move\r\n        const aiMove = getBestMove(currentBoardState, \"O\", difficulty);\r\n        \r\n        if (aiMove !== null) {\r\n          const newBoard = makeMove(currentBoardState, aiMove, \"O\");\r\n          if (newBoard) {\r\n            // Update board and switch to player X\r\n            setBoard(newBoard);\r\n            setCurrentPlayer(\"X\");\r\n            isAIMovingRef.current = false;\r\n            setIsAITurning(false);\r\n            aiMoveTimeoutRef.current = null;\r\n            return;\r\n          }\r\n        }\r\n        \r\n        // No valid move or game ended\r\n        isAIMovingRef.current = false;\r\n        setIsAITurning(false);\r\n        aiMoveTimeoutRef.current = null;\r\n      }, 300); // 300ms delay to show AI is \"thinking\"\r\n\r\n      return cleanup;\r\n    }\r\n\r\n    return cleanup;\r\n  }, [board, currentPlayer, gameMode, difficulty, winner]);\r\n\r\n  // Handle square click\r\n  const handleSquareClick = useCallback(\r\n    (index: number) => {\r\n      // Don't allow moves if game is over or it's AI's turn\r\n      if (winner || isAITurning || !currentPlayer) {\r\n        return;\r\n      }\r\n\r\n      // In 1P mode, only allow X (player) to move\r\n      if (gameMode === \"1P\" && currentPlayer === \"O\") {\r\n        return;\r\n      }\r\n\r\n      // Try to make the move\r\n      const newBoard = makeMove(board, index, currentPlayer);\r\n      if (!newBoard) {\r\n        return; // Invalid move\r\n      }\r\n\r\n      setBoard(newBoard);\r\n\r\n      // Switch player\r\n      setCurrentPlayer(currentPlayer === \"X\" ? \"O\" : \"X\");\r\n    },\r\n    [board, currentPlayer, winner, gameMode, isAITurning]\r\n  );\r\n\r\n  // Handle new game\r\n  const handleNewGame = useCallback(() => {\r\n    // Clean up any pending AI moves\r\n    if (aiMoveTimeoutRef.current) {\r\n      clearTimeout(aiMoveTimeoutRef.current);\r\n      aiMoveTimeoutRef.current = null;\r\n    }\r\n    isAIMovingRef.current = false;\r\n    \r\n    setBoard(createEmptyBoard());\r\n    setCurrentPlayer(\"X\");\r\n    setWinner(null);\r\n    setWinningCells([]);\r\n    setIsAITurning(false);\r\n  }, []);\r\n\r\n  // Handle mode toggle\r\n  const handleModeToggle = useCallback(() => {\r\n    const newMode = gameMode === \"1P\" ? \"2P\" : \"1P\";\r\n    setGameMode(newMode);\r\n    // Reset game when changing mode\r\n    handleNewGame();\r\n  }, [gameMode, handleNewGame]);\r\n\r\n  // Handle difficulty change\r\n  const handleDifficultyChange = useCallback(\r\n    (newDifficulty: Difficulty) => {\r\n      setDifficulty(newDifficulty);\r\n      // Reset game when changing difficulty\r\n      handleNewGame();\r\n    },\r\n    [handleNewGame]\r\n  );\r\n\r\n  // Check if game is disabled\r\n  const isGameDisabled = winner !== null || isAITurning;\r\n\r\n  return (\r\n    <main className=\"relative flex min-h-screen flex-col items-center justify-center p-4 md:p-6 lg:p-8 overflow-hidden\">\r\n      {/* Gradient Background */}\r\n      <div className=\"absolute inset-0 bg-gradient-to-br from-primary/5 via-background to-destructive/5 dark:from-primary/10 dark:via-background dark:to-destructive/10\" />\r\n      <div className=\"absolute inset-0 bg-[radial-gradient(circle_at_50%_50%,rgba(120,119,198,0.1),transparent_50%)]\" />\r\n      \r\n      {/* Glassmorphism Card Container */}\r\n      <AnimatePresence mode=\"wait\">\r\n        <motion.div\r\n          key={`${gameMode}-${difficulty}`}\r\n          className=\"relative w-full max-w-2xl mx-auto space-y-6 md:space-y-8 z-10\"\r\n          initial={{ opacity: 0, y: 20, scale: 0.95 }}\r\n          animate={{ opacity: 1, y: 0, scale: 1 }}\r\n          exit={{ opacity: 0, y: -20, scale: 0.95 }}\r\n          transition={{ duration: 0.5, ease: \"easeOut\" }}\r\n        >\r\n          {/* Glassmorphism Card */}\r\n          <motion.div\r\n            className=\"backdrop-blur-xl bg-card/80 dark:bg-card/60 border border-border/50 rounded-2xl md:rounded-3xl shadow-2xl p-4 md:p-6 lg:p-8\"\r\n            initial={{ opacity: 0 }}\r\n            animate={{ opacity: 1 }}\r\n            transition={{ duration: 0.3, delay: 0.1 }}\r\n          >\r\n            <Header\r\n              gameMode={gameMode}\r\n              currentPlayer={currentPlayer}\r\n              winner={winner}\r\n              difficulty={difficulty}\r\n            />\r\n\r\n            <Board\r\n              board={board}\r\n              onSquareClick={handleSquareClick}\r\n              winningCells={winningCells}\r\n              disabled={isGameDisabled}\r\n            />\r\n\r\n            <Controls\r\n              onNewGame={handleNewGame}\r\n              onModeToggle={handleModeToggle}\r\n              onDifficultyChange={handleDifficultyChange}\r\n              gameMode={gameMode}\r\n              difficulty={difficulty}\r\n              disabled={isAITurning && !winner}\r\n            />\r\n          </motion.div>\r\n        </motion.div>\r\n      </AnimatePresence>\r\n    </main>\r\n  );\r\n}\r\n"],"names":["module","exports","require","vendored","React","AppRouterContext","HooksClientContext","ServerInsertedHtml","process","env","NEXT_RUNTIME","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK","ReactJsxRuntime"],"mappings":"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","ignoreList":[0,1,2,3,4,5]}